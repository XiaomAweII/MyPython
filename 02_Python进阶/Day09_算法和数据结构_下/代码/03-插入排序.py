"""
插入排序:
    概述/原理:
        把列表分成两份, 即: 前边的是有序列表, 后边的是无序列表, 然后拿着无序列表的每个元素, 插入到 有序列表的合适位置即可.
        大白话: 假设列表的第1个元素 属于有序列表, 其它元素都是无序列表的, 逐个获取, 然后插入到 有序列表中合适的位置即可.
    推理过程:  假设列表长度为 5
        比较的轮数       每轮比较的次数     谁(索引)和谁(索引)比较             外循环(i), 内循环(j)
            1               1               1 和 0                         1        1 ~ 0
            2               2               2和1, 2和0                     2        2 ~ 0
            3               2               3和2, 3和1, 3和0               3        3 ~ 0
            4               1               4和3, 4和2, 4和1, 4和0         4        4 ~ 0
    核心:
        1. 比较的总轮数.      列表长度 - 1
        2. 每轮比较的次数.    i ~ 0
        3. 谁和谁比较.       my_list[j] 和 my_list[j - 1]
    时间复杂度:
        最优时间复杂度: O(n)
        最坏时间复杂度: O(n²)
    插入排序属于 稳定排序算法.
"""


# 1. 定义函数 select_sort(my_list), 表示: 插入排序.
def insert_sort(my_list):
    """
    通过插入排序的思路, 对 列表元素 进行排序.
    :param my_list: 要进行排序的列表
    :return:
    """
    # 1.1 获取列表的长度.
    n = len(my_list)
    # 1.2 开始每轮 每次的比较
    for i in range(1, n):           # 外循环, 控制: 比较的轮数. 假设n为5, 则 i的值: 1, 2, 3, 4
        for j in range(i, 0, -1):   # 内循环, 控制: 每轮比较的次数.    这里的结束索引写0的原因是: 下述的比较有个 j - 1的动作, 是为了防止出现: 索引越界异常.
            # 1.3 具体的比较过程: 如果当前元素 比 min_index 记录的元素还要小, 就用 min_index 记录住该元素的索引.
            if my_list[j] < my_list[j - 1]:
                # 后边的值, 比前边的值小, 就交换.
                my_list[j], my_list[j - 1] = my_list[j - 1], my_list[j]
            else:
                # 走这里, 说明, 后边的值, 大于等于前边的值. 直接break
                break

# 在main函数中, 测试
if __name__ == '__main__':
    # 2. 定义列表, 记录要排序的数字.
    my_list = [5, 3, 4, 7, 2]
    # my_list = [2, 3, 4, 5, 7]
    print(f'排序前: {my_list}')

    # 3. 具体的排序动作.
    insert_sort(my_list)
    print(f'排序后: {my_list}')
