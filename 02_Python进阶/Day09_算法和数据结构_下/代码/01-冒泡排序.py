"""
排序 算法 相关介绍:
    概述:
        排序:    指的是按照一定的规则, 对一些数据进行升序 或者 降序排列.
        排序算法: 指的是实现 排序动作的 思路, 方法.
    分类:
        稳定性算法:      排序后, 相同元素的相对位置 保持不变.
        不稳定性算法:    排序后, 相同元素的相对位置 发生改变.
    举例:
        稳定性算法:
            冒泡排序, 插入排序..
        不稳定性算法:
            选择排序, 快速排序...


冒泡排序:
    概述/原理:
        相邻元素两两比较, 大的往后走, 这样第1轮比较完毕后, 最大值就在最大索引处.
    核心:
        1. 比较的总轮数.      列表长度 - 1
        2. 每轮比较的次数.    列表长度 - 1 - i(代表: 轮数, 从0开始计数)
        3. 谁和谁比较.       my_list[j] 和 my_list[j + 1]
    时间复杂度:
        最优时间复杂度: O(n)
        最坏时间复杂度: O(n²)
    冒泡排序属于 稳定排序算法.
"""


# 1. 定义函数 bubble_sort(my_list), 表示: 冒泡排序.
def bubble_sort(my_list):
    """
    通过冒泡排序的思路, 对 列表元素 进行排序.
    :param my_list: 要进行排序的列表
    :return:
    """
    # 1.1 获取列表的长度.
    n = len(my_list)
    # 1.2 开始每轮 每次的比较
    for i in range(n - 1):  # 外循环, 控制: 比较的轮数. 假设n为5, 则 i的值: 0, 1, 2, 3
        # 定义变量, 记录每轮交换的次数.
        count = 0
        for j in range(n - 1 - i):  # 内循环, 控制: 每轮比较的次数.
            # 1.3 具体的比较过程: 如果前边元素比后边元素大, 就交换位置.
            if my_list[j] > my_list[j + 1]:
                my_list[j], my_list[j + 1] = my_list[j + 1], my_list[j]
                count += 1      # 走这里, 说明发生了交换.
        # 打印交换结果.
        # print(f'交换了 {count} 次')

        # 细节: 如果 count = 0, 说明没有发生交换, 即: 列表已经是有序的, 无序往后继续比较.
        if count == 0:
            break


# 在main函数中, 测试
if __name__ == '__main__':
    # 2. 定义列表, 记录要排序的数字.
    # my_list = [5, 3, 4, 7, 2]
    my_list = [2, 3, 4, 5, 7]
    print(f'排序前: {my_list}')

    # 3. 具体的排序动作.
    bubble_sort(my_list)
    print(f'排序后: {my_list}')
