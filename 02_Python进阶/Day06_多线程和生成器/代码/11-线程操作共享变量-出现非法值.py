"""
背景:
    1. 线程之间数据是共享的, 进程之间数据是相互隔离的.
    2. 如果多线程 并发 操作同一数据(共享数据), 就有可能会引发安全问题, 出现非法值.
       可以用 线程同步(加锁)的 思路来解决.

需求:
    定义两个函数, 实现循环100W次, 每循环一次给全局变量+1, 创建两个子线程执行对应的两个函数, 并观察结果.

问题描述:
    按照上述的需求, 实现了代码, 我们要的结果是 100W, 200W, 但是发现出现了非法值, 如何产生的呢?
产生原因:
    多线程 并发 操作同一数据(共享数据), 就有可能会引发安全问题.
    就是1个线程还没有完整的执行完之前, 被另1个线程抢走了资源, 就会出现 非法值.
具体的分析流程:
    正常的计算动作:
        1. 假设 g_num = 0, 此时线程1抢到了资源. 它会去读取 g_num的值, 然后对其累加1, 之后: g_num => 1
        2. 假设此时线程2抢到了资源, 它会去读取 g_num的值, 然后其累加1, 之后: g_num => 2
        3. 这个是正常的情况, 每个线程在运算的过程中, 都没有其他的线程来"干扰"

    现在的(加锁前)的计算动作:
        1. 假设 g_num = 0
        2. 此时 线程1抢到了资源, 它会去读取 g_num的值 g_num = 0, 线程1还没有来得及计算的时候, 此时被线程2抢走了资源.
        3. 此时 线程2 也会去读取 g_num的值 g_num = 0, 然后进行运算.
            线程1 运算: g_num = 0    =>    g_num = 1
            线程2 运算: g_num = 0    =>    g_num = 1
        4. 结论: 线程1和线程2分别对g_num 累加1, 相当于加了2次, 但是 g_num最终只加了1.

解决方案:
    下个视频讲.
"""


# 导包
import threading

# 1. 定义全局变量.
g_num = 0

# 2. 定义get_sum1()函数, 实现对 g_num 全局变量, 累加 100W次.
def get_sum1():
    global g_num    # 声明后续操作的 g_num变量是 全局变量
    # 具体的累加100W次即可.
    for i in range(1000000):
        g_num += 1
    print(f'get_sum1函数, 累加后结果为: {g_num}')       # 100W


# 3. 定义get_sum2()函数, 实现对 g_num 全局变量, 累加 100W次.
def get_sum2():
    global g_num    # 声明后续操作的 g_num变量是 全局变量
    # 具体的累加100W次即可.
    for i in range(1000000):
        g_num += 1
    print(f'get_sum2函数, 累加后结果为: {g_num}')       # 200W

# main函数
if __name__ == '__main__':
    # 4. 创建两个线程, 分别关联上述的两个函数.
    t1 = threading.Thread(target=get_sum1)
    t2 = threading.Thread(target=get_sum2)

    # 5. 启动线程.
    t1.start()
    t2.start()