​	

### 二分查找（Binary Search）

二分查找通常应用于有序数组中查找特定元素的过程。其基本思想是：

1. 将数组分成两半。
2. 检查中间元素是否与目标值相等。
3. 如果中间元素小于目标值，则在右半边重复步骤1-2。
4. 如果中间元素大于目标值，则在左半边重复步骤1-2。
5. 重复此过程直到找到目标值或确定目标值不存在。

### 二分答案（Binary Search on the Answer）

二分答案是一种更广泛的概念，它应用于那些可以通过二分查找技术来确定最佳解的问题。在这种情况下，“答案”可能是指一个范围内的数值，而不仅仅是数组中的元素。

二分答案的基本思想是：

1. 定义一个合理的搜索空间，即答案可能存在的范围。
2. 在这个范围内进行二分查找，每次尝试一个中间值。
3. 根据中间值的结果调整搜索范围。
4. 重复此过程直到找到满足要求的最佳解。

### 区别

二分查找（Binary Search）和二分答案（Binary Search on the Answer）这两个术语经常被用来描述类似的算法思想，但它们的应用场景有所不同。

- **应用场景**：二分查找通常应用于在一个有序数组中查找特定值。而二分答案则用于寻找一个最优解，这个最优解可能不是数组中的元素，而是基于某种条件下的最优值。
- **搜索目标**：二分查找的目标是在数组中找到一个确切的值。而二分答案的目标是找到满足某些条件下的最优解。
- **输入类型**：二分查找通常需要一个有序的数组作为输入。而二分答案的输入可以是任何类型的数据，只要能定义一个有效的搜索空间即可。

### 示例问题

在下面的问题中，使用的是二分答案的方法。定义了一个合理的搜索空间（最低高度到最高高度），并在该范围内进行二分查找以找到能满足需求的最高高度。

```
# 伐木工人 Mirko 需要砍 M 米长的木材。对 Mirko 来说这是很简单的工作，因为他有一个漂亮的新伐木机，可以如野火一般砍伐森林。
# 不过，Mirko 只被允许砍伐一排树。
# Mirko 的伐木机工作流程如下:
# Mirko 设置一个高度参数 H(米)，伐木机升起一个巨大的锯片到高度 H并锯掉所有树比 H 高的部分(当然，树木不高于 H 米的部分保持不变)。
# Mirko 就得到树木被锯下的部分。
# 例如，如果一排树的高度分别为 20,15,10 和 17，Mirko 把锯片升到 15 米的高度，切割后树木剩下的高度将是 15,15,10 和 15，
# 而 Mirko 将从第1棵树得到5米，从第4棵树得到2米，共得到7米木材，
# Mirko 非常关注生态保护，所以他不会砍掉过多的木材。这也是他尽可能高地设定伐木机锯片的原因。
# 请帮助 Mirko 找到伐木机锯片的最大的整数高度 ，使得他能得到的木材至少为 M 米。换句话说，如果再升高 1 米，他将得不到 M 米木材。
#
# 输入格式
# 第 1行 2 个整数 N 和 M，N 表示树木的数量，M 表示需要的木材总长度。
# 第2 行 N 个整数表示每棵树的高度。
# 输出格式
# 1 个整数，表示锯片的最高高度。
# 代码如下:


def find_optimal_height(N, M, heights):
    # 初始化边界
    low = 0
    high = max(heights)

    while low < high:
        mid = (low + high + 1) // 2  # 我们希望向右偏移，以找到最高的有效高度

        # 计算在当前高度下可以获得的木材量
        wood_collected = sum(max(h - mid, 0) for h in heights)

        if wood_collected >= M:  # 可以获得足够的木材
            low = mid  # 尝试更高的高度
        else:  # 不能获得足够的木材
            high = mid - 1  # 降低高度

    return low


# 键盘输入
# 输入格式
# 第 1行 2 个整数 N 和 M，N 表示树木的数量，M 表示需要的木材总长度。
# 第2 行 N 个整数表示每棵树的高度。
# 输出格式
# 1 个整数，表示锯片的最高高度。
if __name__ == "__main__":
    N, M = map(int, input().split())
    heights = list(map(int, input().split()))

    # 执行函数并打印结果
    optimal_height = find_optimal_height(N, M, heights)
    print(optimal_height)
```



### 滑动窗口算法



滑动窗口算法是一种高效地处理数组或字符串问题的技术，特别适用于需要在连续子数组或子串上执行操作的情况。滑动窗口算法的核心思想是维护一个窗口，这个窗口可以在数组或字符串上移动，并且可以根据需要动态地调整大小。

滑动窗口算法通常分为两种类型：固定大小的滑动窗口和可变大小的滑动窗口。在这两种类型中，可变大小的滑动窗口更为常见，因为它可以更灵活地适应不同的问题需求。

下面通过一个具体的例子来解释如何使用 Python 实现滑动窗口算法。

### 示例问题

假设我们需要找到一个数组中的最小覆盖子数组，这个子数组包含了给定的目标元素集合。例如，给定一个数组 `s` 和一个目标字符串 `t`，我们需要找到 `s` 中包含 `t` 中所有字符的最短子串。

### 问题描述

给定两个字符串 `s` 和 `t`，找出 `s` 中包含 `t` 所有字符的最短子串。

### 解决方案

我们可以使用可变大小的滑动窗口算法来解决这个问题。

1. **初始化**：创建一个字典来记录 `t` 中每个字符出现的次数，同时创建另一个字典来记录当前窗口内字符的出现次数。
2. **扩展窗口**：从左端开始遍历 `s`，每次加入一个新字符到窗口中，并更新窗口内字符计数。
3. **收缩窗口**：当窗口包含所有 `t` 中的字符后，从窗口的左侧移除字符，直到窗口不再包含所有 `t` 中的字符为止。
4. **更新答案**：记录每次窗口满足条件时的长度，并保留最短的一个。

接下来是具体的 Python 代码实现：



```
# 给定两个字符串 `s` 和 `t`，找出 `s` 中包含 `t` 所有字符的最短子串。

from collections import Counter

def min_window_substring(s, t):
    if not s or not t:
        return ""

    # 字典来记录 t 中每个字符出现的次数
    need = Counter(t)
    missing = len(t)

    # 左右指针，以及结果变量
    left = start = end = 0
    for right, char in enumerate(s, 1):
        # 如果当前字符在需要的字符列表中，减少 missing
        if need[char] > 0:
            missing -= 1
        # 更新 need 字典中当前字符的计数
        need[char] -= 1

        # 当 missing 为 0 时，表示当前窗口已经包含 t 中的所有字符
        if missing == 0:
            # 移除左边不需要的字符
            while left < right and need[s[left]] < 0:
                need[s[left]] += 1
                left += 1

            # 更新结果
            if end == 0 or right - left <= end - start:
                start, end = left, right

            # 准备移除左端点
            need[s[left]] += 1
            missing += 1
            left += 1

    return s[start:end]


# 测试
s = "ADOBECODEBANC"
t = "ABC"
result = min_window_substring(s, t)
print(result)  # 输出应为 "BANC"
```

这段代码首先定义了一个函数 `min_window_substring`，它接收两个字符串 `s` 和 `t` 作为输入，并返回包含 `t` 中所有字符的最短子串。

在函数内部，使用了 `Counter` 类来统计 `t` 中每个字符的出现次数，并且维护了一个 `missing` 变量来追踪窗口是否已经包含所有 `t` 中的字符。通过左右指针和 `need` 字典，我们能够有效地扩展和收缩窗口，并更新结果。

### 执行操作使频率操作分数最大

```
# 执行操作使频率分数最大
#
# 给你一个下标从 0 开始的整数数组 nums 和一个整数 k 。
# 你可以对数组执行 至多 k 次操作：
# 从数组中选择一个下标 i ，将 nums[i] 增加 或者 减少 1 。
# 最终数组的频率分数定义为数组中众数的 频率 。
# 请你返回你可以得到的 最大 频率分数。
# 众数指的是数组中出现次数最多的数。一个元素的频率指的是数组中这个元素的出现次数。

# 示例 1：
#
# 输入：nums = [1,2,6,4], k = 3
# 输出：3
# 解释：我们可以对数组执行以下操作：
# - 选择 i = 0 ，将 nums[0] 增加 1 。得到数组 [2,2,6,4] 。
# - 选择 i = 3 ，将 nums[3] 减少 1 ，得到数组 [2,2,6,3] 。
# - 选择 i = 3 ，将 nums[3] 减少 1 ，得到数组 [2,2,6,2] 。
# 元素 2 是最终数组中的众数，出现了 3 次，所以频率分数为 3 。
# 3 是所有可行方案里的最大频率分数。
# 示例 2：
#
# 输入：nums = [1,4,4,2,4], k = 0
# 输出：3
# 解释：我们无法执行任何操作，所以得到的频率分数是原数组中众数的频率 3 。
# 代码如下:


def maxFrequencyScore(nums, k):
    nums.sort()
    copy_sum = nums
    for i in range(1, len(nums)):
        copy_sum[i] += copy_sum[i - 1]

    def check(l, r):
        if r - l == 0:
            return True
        m = (l + r) // 2
        f_left = nums[m] * (m - l + 1) - (copy_sum[m] - copy_sum[l - 1] if l else copy_sum[m])
        f_right = (copy_sum[r] - copy_sum[m - 1] if m else copy_sum[r]) - nums[m] * (r - m + 1)
        return f_left + f_right <= k

    l = 0
    freq = 1
    for r in range(len(nums)):
        while not check(l, r):
            l += 1
        freq = max(freq, r - l + 1)
    return freq


# 测试
if __name__ == '__main__':
    nums1 = [1, 2, 3, 4, 5, 6]
    nums2 = [2, 4, 3, 7, 6, 5, 3, 8, 7, 5]
    nums3 = [1, 2, 6, 4]
    k = 4
    result = maxFrequencyScore(nums1, k)
    print(result)  # 输出应为最大频率分数
```