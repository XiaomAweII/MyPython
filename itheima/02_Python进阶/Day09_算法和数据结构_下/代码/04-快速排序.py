"""
快速排序:
    概述/原理:
        1. 假设列表的第1个元素为: 分界值, 然后将 所有小于该分界值的数据, 都放到分界值的左边. 将所有大于或者等于分界值的数据, 都放到分界值的右边.
        2. 此时我们得到的列表就是: 小, 分界值, 大 这样的格式, 第二轮我们又可以从这个列表中, 左右双方再次找出两个分界值, 重复上述的步骤.
        3. 我们发现: 左右双方可以各自独立相互排序. 重复上述的步骤, 直至所有的数据全部排列成功.
    原理, 大白话解释:
        1. 第1轮, 1个分界值.  结果是:                    小                 分界值               大
        2. 第2轮, 2个分界值.  结果是:              (小 分界值 大)            分界值           (小 分界值 大)
        3. 第3轮, 4个分界值.  结果是:   ((小 分界值 大) 分界值 (小 分界值 大))  分界值  (小 分界值 大) 分界值 (小 分界值 大))
        4. ......
        5. 快速排序, 最核心的思想是: 找到区间.
    时间复杂度:
        最优时间复杂度: O(n)
        最坏时间复杂度: O(n²)
    快速排序属于 稳定排序算法.
"""


# 1. 定义函数 quick_sort(my_list, start, end), 表示: 快速排序.
def quick_sort(my_list, start, end):
    """
    通过快速排序的思路, 对 列表元素 进行排序.
    :param my_list: 要进行排序的列表
    :return:
    """
    # 1.1 如果start >= end, 程序结束, 说明排好顺序了.
    if start >= end:
        return      # 结束递归, 即: 排序成功.
    # 1.2 定义变量 left 和 right, 分别表示: 起始 和 结束索引.
    left = start
    right = end
    # 1.3 定义变量 middle(mid), 表示: 分界值, 假设: 列表的第1个元素为: 分界值.
    mid = my_list[start]
    # 1.4 具体的排序过程, 只要 left < right, 就说明没有找完, 就一直找.
    while left < right:
        # 1.5 把 分界值右边 比分界值小的数据 放到 分界值的左边.
        # 1.5.1 如果 right位置的值 比 分界值大, right 就 -= 1
        while my_list[right] >= mid and left < right:
            right -= 1
        # 1.5.2 走到这里, 说明, right索引的值 比分界值 小, 就赋值即可, 即: 把该值放到分界值的左边.
        my_list[left] = my_list[right]
        # 1.6 把 分界值左边 比分界值大的数据 放到 分界值的右边.
        # 1.6.1 如果 left位置的值 比 分界值小, left 就 += 1
        while my_list[left] < mid and left < right:
            left += 1
        # 1.6.2 走到这里, 说明, left索引的值 比分界值 大, 就赋值即可, 即: 把该值放到分界值的右边.
        my_list[right] = my_list[left]
    # 1.7 走到这里, 说明 left >= right, 即: left索引的位置, 就是: 分界值的位置.
    my_list[left] = mid
    # 1.8 走到这里, 说明本轮分界值位置都已锁定, 递归继续往下继续: 分别对分界值左边 和 分界值右边的数据, 做重复操作即可.
    # 1.8.1 分界值左边的数据, 继续排序.
    quick_sort(my_list, start, left - 1)
    # 1.8.2 分界值右边的数据, 继续排序.
    quick_sort(my_list, right + 1, end)


# 在main函数中, 测试
if __name__ == '__main__':
    # 2. 定义列表, 记录要排序的数字.
    my_list = [5, 3, 4, 7, 2]
    # my_list = [2, 3, 4, 5, 7]
    print(f'排序前: {my_list}')

    # 3. 具体的排序动作.
    quick_sort(my_list, 0, len(my_list) - 1)
    print(f'排序后: {my_list}')
