"""
回顾: 可变 和 不可变类型
    概述:
        可变 和 不可变类型区分依据是: 在不改变地址值的情况下, 内容是否可以发生变化, 可以: 可变类型, 不可以: 不可变类型.
    分类:
        可变类型:  列表, 字典, 集合
        不可变类型: 整型, 浮点型, 字符串, 布尔型, 元组.

深浅拷贝解释:
    概述:
        深浅拷贝一般在面试的时候出现的几率比较大, 简单来说: 深拷贝拷贝的多, 浅拷贝拷贝的少.
    细节:
        1. 深浅拷贝都可以操作 可变 和 不可变类型, 但是一般操作 可变类型. 几乎不会操作 不可变类型.
        2. 深浅拷贝其实指的就是: copy模块的两个函数.
            深拷贝: deepcopy()
            浅拷贝: copy()
        3. 浅拷贝只拷贝第1层(引用层), 不拷贝(数据层), 深拷贝: 除了拷贝引用层, 还会拷贝数据层.
"""

import copy

# 需求1: 浅拷贝可变类型: 只拷贝第1层数据, 深层次数据不拷贝
def dm02_浅拷贝可变类型():
    a = [1, 2, 3]
    b = [11, 22, 33]
    c = [6, 7, a, b]

    # 测试1 id(c)和id(d)
    d = copy.copy(c)
    print('id(c)-->', id(c))    # 0x03
    print('id(d)-->', id(d))    # 0x04
    print("id(c)和id(d)值不一样, 说明浅拷贝第1层(最外面一层的数据)")

    # 测试2
    print(id(c[2])) # 0x01
    print(id(a))    # 0x01
    print(id(d[2])) # 0x01
    print("id(c[2])和id(a)值一样, 说明浅拷贝第2层的数据")

    # 修改a[2] = 22
    a[2] = 22
    print('c->', c)  # [6, 7, [1, 2, 22], [11, 22, 33]]
    print('d->', d)  # [6, 7, [1, 2, 22], [11, 22, 33]]

dm02_浅拷贝可变类型()



# 浅拷贝不可变类型: 不会给拷贝的对象c开辟新的内存空间,
# 而只是拷贝了这个对象的引用
def dm03_浅拷贝不可变类型():

    # 不可变类型 a b c
    a = (1, 2, 3)
    b = (11, 22, 33)
    c = (6, 7, a, b)

    d = copy.copy(c)            # 等价于: d = c
    print('id(c)-->', id(c))    # 0x01
    print('id(d)-->', id(d))    # 0x01
    print("id(c)和id(d)值一样, 说明c和d指向相同的内存空间")
    # 不可变类型本身值都是不能被修改的,没有再浪费内存空,
    # 所以程序员要copy不可变类型, python解释器直接返回值地址(别名/引用)

dm03_浅拷贝不可变类型()